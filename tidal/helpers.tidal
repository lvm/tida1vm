import Data.Maybe

{-
FUNX
-}

-- bgold's
let maybeInd xs i | i < length xs = Just $ xs!!i
                  | otherwise = Nothing
    chordate cs m n = map (+m) $ cs!!n
    unMaybe = (fromJust <$>) . filterValues isJust
    flatpat p = stack [unMaybe $ fmap (`maybeInd` i) p | i <- [0..9]]
    enchord chords pn pc = flatpat $ (chordate chords) <$> pn <*> pc
--  $ n (slowcat $ map (flip toScale $ "[0 1 2 3  4 3 2 1  0 -1 0 -1  0 ~ ~ ~]") [minor, kumai, hirajoshi, iwato])
--  $ n (toScale major "[0 1 2 3  4 3 2 1  0 -1 0 -1  0 ~ ~ ~]/4")
    toScale::[Int] -> Pattern Int -> Pattern Int
    toScale s p = (+) <$> fmap (s!!) notep <*> fmap (12*) octp
      where notep = fmap (`mod` (length s)) p
            octp  = fmap (`div` (length s)) p
    somecyclesBy x = when (test x) -- cycle-by-cycle version of sometimesBy
      where test x c = (timeToRand $ fromIntegral c) < x
    -- a new random number each cycle, looping after n cycles
    cyclerand n = Pattern $ \(s,e) -> [((s,e),(s,e),timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]
    cycleirand m n = Pattern $ \(s,e) -> [((s,e),(s,e), floor $ (*m) $ timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]


-- anny's
let bpm b = cps (b/60)
    tmod s e = (# nudge (scale 0 s $ fmap (**e) saw1))
    tmod' s e = tmod (s*(1/(105/60))) e
    mt s d i = slow s $ tmod' 0.5 3 $ density d $ i


-- danielmkarlson's
let runnow d p = do now <- getNow
                    d $ (nextSam now) ~> p
    oneshot d p = runnow d $ seqP [(0, 1, p)]


-- based on slowspread :-)
let randspread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
    randspread f xs p = randcat $ map (\x -> f x p) xs


-- yaxu's
let loopFirst p = splitQueries $ Pattern f
      where f a@(s,e) = mapSnds' plus $ mapFsts' plus $ arc p (minus a)
              where minus = mapArc (subtract (sam s))
                    plus = mapArc (+ (sam s))
    outside n = inside (1/n)
    timeLoop n = outside n loopFirst
    seqPLoop ps = timeLoop (maximum $ map (\(_,x,_) -> x) ps) $ seqP ps

{-
SynthDef generic params.
-}

let mf x = fst $ pF x (Just 0)
    mi x = fst $ pI x (Just 0)

{-
SynthDef params
-}

let amp = mf "amp"
    ctf = mf "ctf"
    detune = mf "detune"
    freq = mf "freq"
    lpcutoff = mf "lpcutoff"
    lforate = mf "lforate"
    lfo = mf "lfo"
    numharm = mf "numharm"
    ratio = mf "ratio"
    rq = mf "rq"
    sinfreq = mf "sinfreq"
